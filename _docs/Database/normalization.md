---
title: 정규화(Normalization)
category: DataBase
date:   2020-07-05 00:30:59
comments: true
order: 1
---

# 1. 정규화 탄생 배경
* 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 __정보가 중복 저장__ 되며 저장 공간을 낭비하게된다.
* 중복된 정보로 인해 __갱신이상__ 이 발생하게 된다.
* 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 __어느 것이 정확한지 알 수 없게 된다.__

이러한 문제를 해결하기 위해 __정규화 과정을 거치는 것__ 이다.

## 1-1. 갱신이상
* __삽입 이상(insertion anomalies)__ 
  + 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.
* __삭제 이상(deletion anomalies)__ 
  + 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말한다.
* __수정(갱신)이상(modification anomalies)__ 
  + 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.

# 2. 정규화 란
* 관계형 데이터베이스(RDB)에서 __중복을 최소화하기 위해 데이터를 구조화__ 하는 작업이다.
* __Bad__ 릴레이션의 애트리뷰트들을 나누어서 __Good__ 작은 릴레이션으로 __분해하는 작업__ 을 말한다.
* 정규화 과정을 거치게 되면 __정규형을 만족__ 하게 된다.
  + __정규형 이란__ 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말한다.
  + 1 정규형, 제 2 정규형, 제 3 정규형 등이 존재한다.

## 2-1. 정규화의 목적
1. 불필요한 데이터(data redundancy)를 제거한다.
2. 데이터 저장을 "논리적으로" 한다.

## 2-2. Bad 릴레이션은 무엇인가?
* 엔티티를 구성하고 있는 애트리뷰트 간에 __함수적 종속성(Functional Dependency)__ 을 판단하여 __Bad 릴레이션을 파악__ 한다.
* 판단된 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다.
* 즉, 각각의 정규형마다 어떠한 __함수적 종속성을 만족하는지에 따라 정규형이 정의__ 되고, 그 정규형을 __만족하지 못하는 정규형을 나쁜 릴레이션__ 으로 파악한다.

## 2-2-1. 함수적 종속성은 무엇인가?
* 함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다.
* X와 Y를 임의의 애트리뷰트 집합이라고 할 때, __X의 값이 Y의 값을 유일하게(unique) 결정한다__ 면 "X는 Y를 함수적으로 결정한다" 라고 한다.
* 함수적 종속성은 __실세계에서 존재하는 애트리뷰트들 사이의 제약조건__ 으로부터 유도된다.
* __각종 추론 규칙에 따라서__ 애트리뷰트들간의 함수적 종속성을 판단할 수 있다.
  + cf> 애트리뷰트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 __집합을 폐포__ 라고 한다.

## 2-3. 각각의 정규형에서 만족해야할 조건
1. 분해의 대상인 분해 집합 D 는 __무손실 조인 을 보장__ 해야 한다.
2. 분해 집합 D 는 __함수적 종속성을 보존__ 해야 한다.

# 3. 정규형
## 3-1. 제 1 정규형
* 애트리뷰트의 도메인이 오직 __원자값만을 포함__ 하고, __튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값__ 을 가져야 한다.
* 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 __비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태__ 를 말한다.

#### 예시

|  Student |  Age |  Subject |
|:--------:|:--------:|:--------:|
| Adam | 16 | Biology, Maths |
| Alex | 14 | Maths |
| kevien | 18 |  Maths |

__제 1 정규형__ 은 각 로우마다 컬럼의 값이 1개씩만 있어야 합니다. 이를 컬럼이 __원자값(Atomic Value)를 갖는다고 합니다__.

위의 경우 Adam의 Subject가 Biology와 Maths 두 개 이기 때문에 1차 정규형을 만족하지 못합니다. 만약 이를 만족 시키고 싶다면 아래와 같이 한 개의 로우를 더 만들면 됩니다.

|  Student |  Age |  Subject |
|:--------:|:--------:|:--------:|
| Adam | 16 | Biology  |
| Adam | 16 | Maths |
| Alex | 14 | Maths |
| kevien | 18 |  Maths |

결과적으로 제1 정규화를 함으로써 데이터 redundancy는 더 증가하였습니다. __데이터의 논리적 구성을 위해 이 부분을 희생하는 것__ 으로 볼 수 있습니다.

## 3-2. 제 2 정규형
* 테이블의 모든 컬럼(열)이 __완전 함수적 종속이면 제 2 정규형을 만족__ 한다고 볼 수 있다.
* __완전 함수적 종속__ 이란 X -> Y 라고 가정했을 때, X 의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다.
* 즉, 키가 아닌 __열들이 각각 후보키에 대해 결정되는 릴레이션 형태__ 를 말한다.

#### 예시

|  Student |  Age |  Subject |
|:--------:|:--------:|:--------:|
| Adam | 16 | Biology  |
| Adam | 16 | Maths |
| Alex | 14 | Maths |
| kevien | 18 |  Maths |

* 2차 정규화부터가 본격적인 정규화의 시작이라고 볼 수 있습니다. 2차 정규형은 __테이블의 모든 컬럼이 완전 함수적 종속을 만족__ 하는 것입니다.
* 이게 무슨 말이냐면 기본키중에 특정 컬럼에만 종속된 컬럼(부분적 종속)이 없어야 한다는 것입니다.
* 위 테이블의 경우 기본키는 (Student, Subject) 두 개로 볼 수 있습니다. 이 두 개가 합쳐져야 한 로우를 구분할 수가 있습니다. 
* 근데 Age의 경우 이 기본키중에 Student에만 종속되어 있습니다. 
* 즉, Student 컬럼의 값을 알면 Age의 값을 알 수 있습니다. 따라서 Age가 두 번 들어가는 것은 불필요한 것으로 볼 수 있습니다.

<br />

* Student Table & Subject Table

| Student Table-> | Student | Age | Subject Table-> | Student | Subject |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| . | Adam | 16 | . | Adam | Biology |
| . | Alex | 14 | . | Adam | Maths |
| . | kevien | 18 | . | Alex | Maths |
| . | . | . | . | kevien | Maths |

이를 해결하기 위한 방법은 위 처럼 __테이블을 쪼개는 것__ 입니다. 그러면 두 테이블 모두 2차 정규형을 만족하게 됩니다. 

위 테이블의 경우 __삽입/갱신/삭제 이상을 겪지 않게됩니다.__ 하지만 조금 더 복잡한 테이블의 경우, 갱신 이상을 겪기도하는데 이를 해결하는 것이 바로 __3차 정규화__ 입니다.


## 3-3. 제 3 정규형
* 어떠한 비주요 애트리뷰트도 __기본키에 대해서 이행적으로 종속되지 않으면__ 제 3 정규형을 만족한다고 볼 수 있다.
* 이행 함수적 종속이란 X - >Y, Y -> Z의 경우에 의해서 추론될 수 있는 X -> Z의 종속관계를 말한다.
* 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.

#### 예시

|Student_Detail Table ->| Student_id | Student_name | DOB | Street | city | State | Zip |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|.|.|.|.|.|.|.|.|

* 위와 같은 데이터 구성을 생각해봅시다. __Student_id가 기본키__ 이고, 기본키가 하나이므로 __2차 정규형은 만족하는 것__ 으로 볼 수 있습니다.
* 하지만 이 데이터의 Zip컬럼을 알면 Street, City, State를 결정할 수 있습니다. 
* 또한 여러명의 학생들이 같은 Zip코드를 갖는 경우에 Zip코드만 알면 Street, City, State가 결정되기 때문이 이 컬럼들에는 중복된 데이터가 생길 가능성이 있습니다. 
* 정리하면 3차 정규형은 __기본키를 제외한 속성들 간의 이행적 함수 종속이 없는 것__ 입니다. 
* 풀어서 말하자면, 기본키 이외의 다른 컬럼이 그외 다른 컬럼을 결정할 수 없는 것입니다.

<br />

* New Student_Detail Table

| Student_id | Student_name | DOB | Zip |
|:--------:|:--------:|:--------:|:--------:|
|.|.|.|.|

* Address Table

| Zip | Street | city | State |
|:--------:|:--------:|:--------:|:--------:|
|.|.|.|.|

3차 정규화는 2차정규화와 마찬가지로 테이블을 분리함으로써 해결할 수 있는데, 위와 같이 두 개의 테이블(New Student_Detail, Address Table)로 나눔으로써 3차 정규형을 만족할 수 있습니다. 

이를 통해 데이터가 논리적인 단위(학생, 주소)로 분리될 수 있고, 데이터의 redundancy도 줄었음을 알 수 있습니다.


## 3-4. BCNF(Boyce-Codd) 정규형
* __여러 후보 키가 존재하는 릴레이션에 해당하는 정규화__ 내용이다.
* __복잡한 식별자 관계에 의해 발생하는 문제를 해결__ 하기 위해 제 3 정규형을 보완하는데 의미가 있다.
* 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다.


각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다.

* 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
* 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
* 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.

수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 __각 릴레이션이 3NF(or BCNF)를 갖게 하는 것__ 이다.

#### 예시

* __BCNF는 (Boyce and Codd Normal Form)__ 3차 정규형을 조금 더 강화한 버전으로 볼 수 있습니다. 
* 이는 3차 정규형으로 해결할 수 없는 이상현상을 해결할 수 있습니다.
* BCNF란 3차정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형입니다.
* 아래와 같은 경우를 생각해보면, 후보키는 수퍼키중에서 최소성을 만족하는 건데, 이 경우 (학생, 과목) 입니다. (학생, 과목)은 그 로우를 유일하게 구분할 수 있습니다. 
* 근데 이 테이블의 경우 교수가 결정자 입니다. (교수가 한 과목만 강의할 수 있다고 가정) 즉, 교수가 정해지면 과목이 결정됩니다. 
* 근데 교수는 후보키가 아닙니다. 따라서 이 경우에 BCNF를 만족하지 못한다고 합니다. 
* 3차 정규형을 만족하면서 BCNF는 만족하지 않는 경우는 언제일까요? 바로 __일반 컬럼이 후보키를 결정하는 경우__ 입니다.

| 학생 | 과목 | 교수 | 학점 |
|:--------:|:--------:|:--------:|:--------:|
| 1 | AB123 | 김첨지 | A |
| 2 | CS123 | 빌게이츠 | A |
| 3 | CS123 | 빌게이츠 | A |


* 위와 같이 테이블이 구성된 경우에 데이터가 중복되고, 갱신 이상이 발생합니다. 
* 예를 들어 빌게이츠가 강의하는 과목명이 바뀌었다면 두 개의 로우를 갱신해야합니다. 
* 이를 해결하기 위해서는 마찬가지로 테이블을 분리합니다.

| 교수 테이블-> | 교수 | 학점 | 수강 테이블-> | 학생 | 과목 | 학점 |
|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| . | 김첨지 | AB123 | . | 1 | AB123 | A |
| . | 빌게이츠 | CS123 | . | 2 | CS123 | A |
| . | 빌게이츠 | CS123 | . | 3 | CS123 | A |

# 4. 정규화의 장점/단점
## 4-1. 장점
* 최소의 데이터로 최적의 데이터베이스구축 및 데이터 중복성 제거
* 종속성 삭제로 데이터의 일관성과 무결성 보장
* 릴레이션에서 발생 가능한 이상현상 제거
* 중복의 최소화로 저장공간의 효율화 달성

## 4-2. 단점
* 릴레이션의 분해로 인해 __릴레이션 간의 연산(JOIN 연산)이 많아진다.__ 이로 인해 질의에 대한 응답 시간이 느려질 수 있다.
* 과다한 검색 조건문 발생으로 부자연스러운 데이터베이스 semantics 초래할 수 있다.

조금 덧붙이자면, __정규화를 수행한다는 것__ 은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 __입력/수정/삭제 이상을 제거__ 하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 __데이터 용량이 최소화되는 효과__ 가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

# 5. 단점에서 미루어볼때 정규화는 언제 진행해야 하는가?
조희를 하는 SQL 문장에서 __조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우__ 에 __반정규화__ 를 적용하는 전략이 필요하다.

## 5-1. 반정규화(De-normalization, 비정규화)
* __반정규화__ 는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다.
* 디스크 I/O가 많아서 조회 시 성능이 저하, 테이블 간 경로가 너무 멀어 조인으로 인한 성능 저하 예상, 칼럼을 계산하여 조회할 때 성능이 저하 예상되는 경우 반정규화를 수행하게 된다.
* 일반적으로 __조회에 대한 처리 성능이 중요하다고 판단될 때__ 부분적으로 반정규화를 고려하게 된다.

## 5-2. 반정규화의 대상?
* 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
* 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
* 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

## 5-3. 반정규화 과정에서 주의할 점은?
반정규화를 과도하게 적용하다 보면 __데이터의 무결성이 깨질 수 있다.__ 또한 입력,수정,삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.
