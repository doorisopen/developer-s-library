# story19. GC 튜닝을 항상 할 필요는 없다
생성일: 2022년 7월 9일 오후 9:37

---

GC 튜닝을 하기 가장 좋은 시점은 시스템이 오픈한 후이다.

이유는 아무리 성능 테스트를 통해서 부하를 준다고 해도, 실제 사용자들이 사용하는 패턴과 동일하게 구현하기 힘들기 때문이다.

**GC 튜닝이 필요 없는 경우**

- -Xms 옵션과 -Xmx 옵션으로 메모리 크기를 지정한 경우
- -server 옵션이 포함된 경우
- DB 작업과 관련된 타임아웃 로그가 남지 않는 경우
- 다른 서버와의 통신시 타임아웃 로그가 남지 않는 경우
    - 타임아웃 로그가 남아있다는 것은 그 시스템을 사용하는 사용자 중 대다수 혹은 일부는 정상적인 응답을 받지 못한 경우가 있는데, 대부분 원격 서버의 문제로 타임아웃이 발생할 수 있지만 GC로 인한 문제일 수 있기 때문에 고려한다.

# GC 튜닝을 하는 이유

Java에서 생성된 객체는 가비지 컬렉터(Garbage Collector)가 처리해서 지운다.

생성된 객체가 많을 수록 GC 처리 대상도 많아지고, 수행 횟수도 증가한다.

즉, 운영하고 있는 시스템이 GC를 적게 하도록 하려면 객체 생성을 줄이는 작업을 먼저 해야 한다.

ex) String 대신 StringBuilder, StringBuffer 사용

**GC 튜닝의 목적**

- Old 영역으로 넘어가는 객체의 수를 최소화한다.
- Full GC의 실행 시간을 줄인다.

## Old 영역으로 넘어가는 객체 수 최소화하기

Generational GC(Oracle JVM에서 제공하는 GC 방식)는 Eden 영역에서 객체가 처음 만들어지고, Survival 영역을 오가다가, 끝까지 남아있는 객체는 Old 영역으로 이동한다.(G1의 경우 약간 상이하게 동작함) 물론 간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있다.

Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다.(객체를 마음대로 New 영역에만 남긴다는 의미가 아님(가능하지도 않음)) 

New 영역의 크기를 잘 조절함으로써 큰 효과를 볼 수 있다.

## Full GC 시간 줄이기

Full GC의 수행 시간은 상대적으로  Young GC에 비하여 길다. 그래서 Full GC 실행에 시간이 오래 소요되면 연계된 여러 부분에서 타임아웃이 발생할 수 있다.

그렇다고 Full GC의 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 OutOfMemoryError 가 발생하거나 Full GC 횟수가 늘어난다.

반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다.

따라서 Old 영역의 크기를 적절하게 잘 설정해야한다.

# GC의 성능을 결정하는 옵션

특정 옵션을 사용한다고 반드시 성능이 좋아지는 것은 아니다. 서비스마다 규모와 트래픽의 차이가 있기 때문에 상황에 맞게 적절히 선택하는 것이 중요하다.

| 구분 | 옵션 | 설명 |
| --- | --- | --- |
| 힙(Heap) 영역 크기 | -Xms | JVM 시작 시 힙 영역 크기 |
|  | -Xmx | 최대 힙 영역 크기 |
| New 영역의 크기 | -XX:NewRatio | New 영역과 Old 영역의 비율 |
|  | -XX:NewSize | New 영역의 크기 |
|  | -XX:NewServivorRatio | Eden 영역과 Survivor 영역의 비율 |

GC 튜닝 시 자주 사용되는 옵션은 -Xms, -Xmx, -XX:NewRatio이다.

특히 -Xms, -Xmx의 경우 필수로 지정해야하는 옵션이고 -XX:NewRatio의 경우 어떻게 설정하느냐에 따라 GC 성능에 많은 차이가 발생한다.

NewRatio는 New 영역과 Old 영역의 비율을 설정하는 옵션인데, -XX:NewRatio=1 로 지정하면 New:Old 의 비율은 1:1이 된다. 2라면 1:2가 된다. 즉, 값이 커지면 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.

**GC 방식 설정 옵션**

| 구분 | 옵션 | 비고 |
| --- | --- | --- |
| Serial GC | -XX:+UseSerialGC |  |
| Parallel GC | -XX:+UseParallelGC
-XX:ParallelGCThreads=value |  |
| Parallel Compacting GC | -XX:+UseParallelOldGC |  |
| CMS GC | -XX:+UseConcMarkSweepGC
-XX:+UseParNewGC
-XX:+CMSParallelRemarkEnabled
-XX:CMSInitiatingOccupancyFraction=value
-XX:+UseCMSInitiatingOccupancyOnly |  |
| G1 | -XX:+UnlockExperimentalVMOptions
-XX:+UseG1GC | JDK 6에서는 두 옵션을 반드시 같이 사용해야 함 |

G1 GC를 제외하고는 각 GC 방식의 첫 번째 줄에 있는 옵션을 지정하면 된다.

그리고 위 GC 방식들 중 특별히 신경 쓸 필요가 없는 방식은 Serial GC다. Serial GC는 클라이언트 장비에 최적화되어 있기 때문이다.

> **Concurrent mode failure**
- Parallel GC와 CMS GC의 가장 큰 차이점은 **압축(Compaction) 작업 여부**이다. 
- **압축 작업**은 메모리 할당 공간 사이에 사용하지 않는 빈 공간이 없도록 옮겨서 메모리 단편화를 제거하는 작업이다.
- **Parallel GC 방식**에서는 Full GC가 수행될 때마다 압축 작업을 진행하기 때문에 시간이 많이 소요된다. 하지만, Full GC가 수행된 이후에는 메모리를 연속적으로 지정할 수 있어 메모리를 더 빠르게 할당할 수 있다.
- **CMS GC**는 압축 작업을 수행하지 않아 속도는 빠르지만 압축 작업을 수행하지 않아 디스크 조각 모음을 실행하기 전의 상태처럼 메모리에 빈 공간이 여기저기 생긴다. 그래서 크기가 큰 객체가 들어갈 수 있는 공간이 없을 수 있다.
- CMS GC 사용 시 Concurrent mode failure 라는 경고가 발생하면서 압축 작업을 수행하게 되는데 압축 시간이 Parallel GC 보다 더 오래 소요된다.
> 

# GC 튜닝 절차

1. **GC 상황 모니터링**
    - GC 상황을 모니터링하며 현재 운영되는 시스템의 GC 상황을 확인해야 한다.
2. **모니터링 결과 분석 후 GC 튜닝 여부 결정**
    - GC 상황을 확인한 후, 결과를 분석하고 GC 튜닝 여부를 결정한다.
    - 분석한 결과가 GC 수행에 소요된 시간이 0.1~0.3초 밖에 안 된다면 굳이 GC 튜닝에 시간을 낭비할 필요가 없다.
3. **GC 방식/메모리 크기 지정**
    - GC 튜닝을 진행하기로 결정된 상황에서 GC 방식을 선정하고 메모리의 크기를 지정한다. 이때 서버가 여러 대라면 서버에 GC 옵션을 서로 다르게 지정해서 GC 옵션에 따른 차이를 확인하는 것이 중요하다.
    - 보통 500MB로 설정
4. **결과 분석**
    - GC 옵션을 지정하고 적어도 24시간 이상 데이터를 수집한 후에 분석을 실시한다.
    - 로그를 분석하며 메모리가 어떻게 할당되는지 확인한다.
    - GC 방식/메모리 크기를 변경해 가며 최적의 옵션을 찾아간다.
5. **서버에 반영 및 적용**