# story11. JSP와 서블릿, Spring에서 발생할 수 있는 여러 문제점
생성일: 2022년 6월 26일 오후 6:34

### JSP 라이프 사이클

1. JSP URL 호출
2. 페이지 번역
3. JSP 페이지 컴파일
4. 클래스 로드
5. 인스턴스 생성
6. jspInit 메서드 호출
7. _jspService 메서드 호출
8. jspDestory 메서드 호출

### 서블릿 라이프 사이클

WAS의 JVM이 시작한 후

- Servlet 객체가 자동으로 생성되고 초기화 되거나, 사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화 된다.

![story11-1](/images/Book/자바성능튜닝가이드/story11-1.png)

- 서블릿은 JVM에 여러 객체로 생성되지 않는다.
- 다시말해, WAS가 시작하고 ‘사용 가능’ 상태가 된 이상 대부분의 서블릿은 JVM에 살아 있고, 여러 스레드에서 해당 서블릿의 service()메서드를 호출하여 공유한다.

### JSP Include 사용

다른 JSP를 호출하여 여러 JSP 파일을 혼합해서 하나의 JSP로 만드는 것

- **정적**인 방식: <%@ include file=”{url}” %>
- **동적**인 방식: <jsp:include page=”{url}” %>

**동적**인 방식이 **정적** 방식보다 **약 30배 더 느리다.**

# 스프링 프레임워크

스프링 프레임워크를 웹 프레임워크로 오해하는 경우가 많다.

하지만, 스프링 프레임워크는 데스크톱과 웹 애플리케이션, 작고 간단한 애플리케이션부터 여러 서버와 연동하여 동작해야 하는 엔터프라이즈 애플리케이션도 범용적인 애플리케이션 프레임워크이다.

- 복잡한 애플리케이션도 POJO(Plain Old Java Object)로 개발할 수 있다.
    - JSP, Servlet에서 Servlet은 POJO가 아니다.(HttpServlet 클래스를 상속받아야하기 때문)
    - 스프링은 HttpServlet 상속 없이 웹 요청을 처리할 수 있다.
- JMS, JMX, Mail, Web Service 등 여러 가지 기능을 POJO 기반으로 사용할 수 있다.
- Dependency Injection(DI), Aspect Oriented Programming(AOP), Protable Service Abstraction(PAS)

> Protable Service Abstraction(PSA)
**환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하려는 추상화
*** PSA: [https://jins-dev.tistory.com/entry/Spring-PSAPortable-Service-Abstraction의-개념](https://jins-dev.tistory.com/entry/Spring-PSAPortable-Service-Abstraction%EC%9D%98-%EA%B0%9C%EB%85%90)
> 

### Dependency Injection

- 의존성 주입, 객체 간의 의존 관계를 관리하는 기술

객체는 보통 혼자서 모든 일을 처리하지 않고, 여러 다른 객체와 협업하여 일을 처리한다. 이때 자신과 협업하는 객체와 자신과의 의존성을 가능한 낮춰야 유리하다.

다시말해, 어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하여 사용하는 것이 아니라 외부에 있는 다른 무언가로 필요로 하는 객체를 주입 받는 기술이다.

```java
public class A {
	B b = new B();
}
```

A 클래스 객체는 항상 B 클래스 객체를 사용한다. 이렇게 되면 나중에 B 객체를 다른 것으로 교체하기 힘들다.

```java
public class A {
	private	B b;
	public A(B b) {
		this.b = b;
	}
}
```

만약 위와 같이 B 객체를 외부에서 넘겨서 주입하는 방식을 사용하면 나중에 다른 객체로 교체하는 것이 쉬워진다.

스프링은 이렇게 의존성을 주입하는 틀을 제공해 준다. 

- **XML**이나 **어노테이션** 등으로 의존성을 주입하는 방법
- **생성자 주입**, **세터(setter) 주입**, **필드 주입** 등 다양한 의존성 주입 방법

### Aspect Oriented Programming(AOP)

관점 지향 프로그래밍, 이 기술은 객체 지향 프로그래밍을 대체하는 기술로 홍보하기도 했다. 하지만, 이 기술은 OOP보다 더 OOP 스럽게 보완해주는 기술이다.

트랜잭션, 로깅, 보완 체크 코드를 생각해 보자. 이런 코드들은 여러 모듈, 여러 계층에 스며들기 마련이다. 

그런데, 필요한 작업이긴 하지만 대부분의 **비슷한 코드가 중복**되고, 코드를 눈으로 읽는 데 방해 가 된다. 이런 코드를 **실제 비즈니스 로직과 분리할 수 있도록 도와주는 것**이 **AOP** 이다.

자바에서 가장 유명한 **AOP 프레임워크는 AspectJ**가 있다.

스프링은 AspectJ와 손쉽게 연동하는 방법을 제공할 뿐 아니라, AspectJ 보다 훨씬 더 사용하기 간편한 방법을 사용한 스프링 AOP를 제공해준다. 이 기술을 잘 활용하면 핵심 비즈니스 코드의 가독성을 높여준다.

### Protable Service Abstraction(PAS)

예를 들어 트랜잭션 처리를 할때, 기술에 따라 JDBC 트랜잭션, iBatis가 제공하는 트랜잭션, Hibernate 트랜잭션을 사용해야할 수도 있다. 글로벌 트랜잭션이 필요한 경우 JTAf를 사용할 수 도 있다.

이렇게 비슷한 기술을 구현하기 위해 코딩하는 방법은 **사용할 라이브러리나 프레임워크에 따라 달라지기 때문에, 추상화가 매우 중요**하다.

스프링은 비슷한 기술을 모두 아우를 수 있는 추상화 계층을 제공하여 기술이 바뀌더라도 비즈니스 로직의 변화가 없도록 도와준다. 스프링의 의존성 주입 기능으로 사용할 객체를 바꿔주는 것뿐이다.

## 스프링 프레임워크 사용 시 발생할 수 있는 문제점들

스프링 사용시 성능 문제가 많이 발생할 수 있는 부분은 **프록시(Proxy)**와 관련되어 있다.

스프링 프록시는 기본적으로 실행 시에 생성된다. 따라서, 요청량이 많은 운영 상황으로 넘어가면 문제가 나타날 수 있다.

프록시를 사용하게 하는 주요 기능

**트랜잭션** @Transactional 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체를 만든다.

**스프링 AOP** 로 별도 기능을 추가하는 경우, 오랜 기간 많은 개발자에게 검증된 트랜잭션과 달리 개발자가 직접 작성한 AOP 코드는 예상하지 못한 성능 문제를 보일 가능성이 높다. 따라서, 간단한 부하 툴을 사용해서라도 성능적인 면을 테스트해야만 한다.

스프링 내부 매커니즘에서 사용하는 **캐시** 또한 주의해서 사용해야한다.

스프링 MVC에서 작성하는 메서드의 리턴 타입으로 문자열을 사용할 수 있다.

```java
@RequestMapping("/members/{id}")
public String hello(@PathVariable Long id) {
	return "redirect: /members/" + id;
}
```

위와 같이 하면 스프링은 해당 문자열에 해당하는 실제 뷰 객체를 찾는 매커니즘을 사용한다.

이 때 매번 동일한 문자열에 대한 뷰 객체를 새로 찾기 보다는 이미 찾아본 뷰 객체를 캐싱해두면 다음에도 동일한 문자열이 반환됐을 때 훨씬 빠르게 뷰 객체를 찾을 수 있다.

스프링이 제공하는 **ViewResolver** 중에 **InternalResourceViewResovler**에는 그러한 **캐싱 기능이 내장**되어 있다.

만약 매번 다른 문자열이 생성될 가능성이 높고, 상당히 많은 수의 키 값으로 캐시 값이 생성될 여지가 있는 상황에서는 문자열을 반환하는 게 메모리에 치명적일 수 있다. 따라서 이런 상황에서는 뷰 이름으로 문자열로 반환하기 보다는 뷰 객체 자체를 반환하는 방법이 메모리 릭을 방지하는 데 도움이 된다.

```java
@RequestMapping("/members/{id}")
public View hello(@PathVariable Long id) {
	return new RedirectView("/members/" + id);
}
```